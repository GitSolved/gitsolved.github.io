---
title: "BYOVD Attack Chain: Exploiting Signed Drivers for Kernel Access and EDR Bypass"
author: SecureYourGear Team
date: 2025-10-15 14:00:00 -0400
categories: [Red Team, Windows Security]
tags: [byovd, driver-exploitation, privilege-escalation, edr-bypass, kernel, windows, rootkit, malware-analysis]
---

In this blog post, I'll walk you through exploiting a vulnerable Windows driver to gain kernel-level access and bypass EDR/AV solutions. You will learn the complete BYOVD attack chain from driver selection and deployment to privilege escalation and defense evasion. I'll use modern tools for efficiency while verifying everything manually to maximize learning. Each step includes detailed explanations to build understanding for both technical and non-technical audiences.

<img src="/assets/img/posts/byovd/byovd_header.png" alt="BYOVD Attack - User Mode to Kernel Mode" width="800">

*BYOVD attacks exploit legitimate signed drivers to inject malicious code from user mode (Ring 3) into kernel mode (Ring 0), bypassing Windows security boundaries.*

## What is the WinRing0 Driver? 

WinRing0 is a kernel mode driver for Windows 11. It was designed to help legitimate software access low-level (Ring 0) hardware functions, such as controlling fans or reading sensor data.

**Why is WinRing0 Vulnerable?**

WinRing0 is problematic because it exposes unrestricted read/write access to all Model Specific Registers (MSRs) via its IOCTL (Input/Output Control) interface. MSRs are special CPU registers that control debugging, system features, and system call handling. Kernel drivers should implement strict validation and limit which MSRs can be accessed, but WinRing0 allows any user mode process to directly manipulate these critical registers without any security checks. Because it's a signed driver, Windows trusts it by default, making it an ideal target for BYOVD attacks. Think about why this is the case? Drivers like WinRing0 were designed to let programs safely control things like computer fans or sensors. But if it was not signed, Windows would treat it as untrusted and block it from loading or giving kernel access. That means the very tools meant to help manage your computer wouldnt work unless they were trusted, which can be used against the computer to launch malicious code into the core of the system. 

Think of WinRing0 as a trusted maintenance worker given keys to every room in a building. The worker has legitimate reasons to access secure areas, so security guards (Windows protections) don't question them. Malicious guests (attackers) can trick the worker into opening security doors, bypassing all the normal badge scanners and access controls. The security system can't detect the attack because the worker is authorized—this is exactly how BYOVD attacks abuse trusted drivers.

<img src="/assets/img/posts/byovd/ring0.png" alt="Windows Privilege Rings - Ring 0 (Kernel) to Ring 3 (Applications)" width="800">

**Bypassing Modern Windows Protections**

Microsoft has implemented several kernel protection mechanisms to prevent exactly this type of attack: **Kernel Mode Code Signing (KMCI)** ensures only signed drivers can load, **PatchGuard** detects and prevents unauthorized kernel modifications, and hardware features like **SMEP/SMAP** (Supervisor Mode Execution/Access Prevention) block kernel execution of user-mode code. However, WinRing0 bypasses all of these because it's a legitimately signed driver that provides an intended interface for MSR access—the protections can't distinguish between legitimate use and malicious exploitation.

*Windows uses a privilege ring architecture where Ring 0 (kernel) has complete system access, while Ring 3 (applications) runs with restricted permissions. The WinRing0 driver allows us to bridge this gap.*

## The Attack: Hijacking System Calls via MSR Manipulation

Among the many MSRs that control critical system functions, two are particularly important for exploitation: **IA32_LSTAR (0xC0000082)** for SYSCALL and **IA32_SYSENTER_EIP (0x00000176)** for SYSENTER. Both contain kernel pointers that define where the CPU jumps when userspace applications request kernel services. On modern Windows x64 platforms (Windows 10/11), the SYSCALL instruction is the standard mechanism for both AMD and Intel CPUs, with IA32_LSTAR pointing to the **KiSystemCall64** function in ntoskrnl.exe—the heart of Windows' system call handling.

Our exploitation strategy targets this exact mechanism. By using WinRing0's unrestricted MSR write capability, we can overwrite the IA32_LSTAR value to redirect it from the legitimate KiSystemCall64 handler to our malicious kernel code. Think of LSTAR like a signpost at a critical junction: every time any application makes a system call (which happens thousands of times per second), the CPU follows this signpost. When we change that signpost to point to our code instead of Windows' handler, we gain execution in the most privileged context possible—Ring 0 kernel mode—with every subsequent system call. 

